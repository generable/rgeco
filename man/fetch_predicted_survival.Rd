% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inference_api.R
\name{fetch_predicted_survival}
\alias{fetch_predicted_survival}
\title{Fetch predicted survival curve over time}
\usage{
fetch_predicted_survival(
  run_id,
  level = c("trial_arm", "study", "subject", "overall"),
  return = c("median", "quantiles", "intervals", "draws"),
  type = c("posterior", "prior"),
  project = NULL,
  project_version_id = NULL
)
}
\arguments{
\item{run_id}{[required] One or several model run_ids. See \code{\link{find_runs}} for a list of runs available.}

\item{level}{The level at which to return predicted values. One of: subject, trial_arm, study, or overall. Default value is per trial_arm.}

\item{return}{The type of summary to return. One of: median, quantiles, intervals, or draws. Default: median}

\item{type}{Whether to return posterior or prior predictions. Default: posterior}

\item{project}{The name of the project to which the run_id belongs.}

\item{project_version_id}{The specific project_version_id to which the run_id belongs. Defaults to the most recent project_version_id if none provided.}
}
\value{
A data.frame in tidy format, with one record per parameter, run_id, and summarized level. See notes for specific details about each return type.
}
\description{
Fetch predicted survival at regular intervals during the follow-up window.
}
\details{
Predicted survival values can be provided at different levels of the hierarchical model:
\enumerate{
  \item Per subject: predict for each subject, using subject-level parameters
  \item Per trial_arm: summarize survival over all subjects in a trial-arm, for each followup timepoint
  \item Per study: summarize survival over all subjects in a study, for each followup timepoint
  \item Overall: summarize survival over all subjects in the run, including simulated data comprising the background set
}

Use the \code{level} argument to select the desired level at which to summarize predicted values.

Authentication (see \code{\link{login}}) is required prior to using this function. This
function accesses information from the Generable API.

There are four slightly different return formats, depending on the \code{return} argument provided. See notes for details.
}
\note{
The columns returned depends on the value of the `return` argument. The default is to return median values for each \code{level} and prediction time (\code{biomarker_time}, in days).

All return formats share a set of columns containing meta-information about the predicted quantities:
\enumerate{
  \item \code{.variable} Text label for the predicted quantity or variable. In this case, "predicted_survival"
  \item \code{run_id} Text field containing the run_id from which each returned value was generated.
  \item \code{.type} Text field containing the type (prior or posterior) of predicted quantity or inferences summarized.
  \item \code{.level} Text field containing the level (subject, trial_arm, or overall) at which the predicted values were prepared.
  \item \code{survival_time} Numeric field containing the study time (days) at which the predicted value was prepared.
  \item \code{subject_id | trial_arm_id | trial_id } If returning predicted values at the subject, study, or trial-arm level, the ids corresponding to the subjects or trial-arms used in the prediction.
}

In addition, there will be a few columns to provide and describe the predicted quantities.
The set of columns included here will depend on the `return` argument:
\enumerate{
  \item if \code{return  == 'median'}, a pair of columns: \code{.value} and \code{.point}
  \item if \code{return == 'quantiles'}, a pair of columns: \code{.value} and \code{quantile}
  \item if \code{return == 'intervals'}, a set of columns: \code{.value}, \code{.width}, \code{.lower}, and \code{.upper} containing the median estimate (.value) along with the lower (.lower) and upper (.upper) bounds for the 50, 80, and 90 percent credible intervals (.width).
     \itemize{
       \item In addition, columns \code{.point} and \code{.interval} describe the type of point estimate ('median') and interval ('qi')
       \item This data structure mimics that returned by \code{\link[tidybayes:median_qi]{median_qi}} function in the \code{\link[tidybayes:tidybayes-package]{tidybayes}} package.
       }
  \item if \code{return == 'draws'}, a set of columns: \code{.value}, \code{.chain}, \code{.iteration}, and \code{.draw} describing the predicted quantities for each draw, chain and iteration. This data structure mimics the \code{\link[posterior:draws_df]{draws_df}} format from the \code{\link[posterior:posterior-package]{posterior}} package.
}
}
\examples{
\dontrun{
library(tidybayes)
library(tidyverse)

login()

# ---- Plot median predicted survival over time ----
d <- fetch_predicted_survival(run_id, level = 'overall')

ggplot(d, aes(x = survival_time, y = .value)) +
  geom_line() +
  scale_y_continuous('Predicted Survival', labels = scales::percent)


# ---- Plot predicted survival over time from intervals ----
d <- fetch_predicted_survival(run_id, level = 'overall', return = 'intervals')

ggplot(d, aes(x = survival_time, y = .value, ymin = .lower, ymax = .upper, group = .width)) +
  geom_lineribbon(alpha = 0.2) +
  scale_y_continuous('Predicted Survival', labels = scales::percent) +
  scale_fill_brewer()


# ---- Plot predicted survival by trial-arm over time ----
d <- fetch_predicted_survival(run_id, level = 'trial_arm', return = 'intervals') \%>\%
     inner_join(fetch_subjects() \%>\% distinct(trial_arm_id, trial_arm_name))

ggplot(d, aes(x = survival_time, y = .value, ymin = .lower, ymax = .upper, group = .width,
   fill = trial_arm_name, colour = trial_arm_name)) +
  geom_lineribbon(alpha = 0.2) +
  scale_y_continuous('Predicted Survival', labels = scales::percent) +
  theme(legend.position = 'bottom') +
  facet_wrap(~ trial_arm_name)


# ----Plot predicted survival over time from draws ----
d <- fetch_predicted_survival(run_id, level = 'overall', return = 'draws')

ggplot(d, aes(x = survival_time, y = .value)) +
  stat_lineribbon(alpha = 0.4, .width = c(0.66, 0.99)) +
  scale_y_continuous('Predicted Survival', labels = scales::percent) +
  scale_fill_brewer() +
  theme_minimal()

# ---- summarize sampling quality ----

library(posterior)
d <- fetch_predicted_survival(run_id, level = 'overall', return = 'draws')

d \%>\% spread(.variable, .value) \%>\%
   group_by(.level, survival_time, .type, run_id) \%>\%
   group_modify(~ summarise_draws(.x))
}

}
