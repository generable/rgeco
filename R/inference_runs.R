
#' List runs from the Generable API
#'
#' List runs from the Generable API for a specific project.
#'
#' A run is generated by a model and a dataset. This function retrieves the
#' attributes about all runs within a project version. The returned `data.frame`
#' contains information about what draws and quantiles are available and the model
#' and dataset ids.
#'
#' The `run_draws` and `run_quantiles` columns contain two named lists of `parameter_names`
#' and `predictive_names`. The `parameter_names` is a list of the parameters of the model, e.g.
#' the sld parameters f, kg, and ks. The `predictive_names` is a list of the predicted quantities,
#' e.g. the predicted survival for each trial arm `predicted_survival_per_trial_arm`.
#'
#' Authentication (see \code{\link{login}}) is required prior to using this function
#' and this pulls the metadata from the Generable API.
#'
#' A project can be specified by using the project name or a specific project version.
#' If a project is specified using the name, data is fetched for the latest version of the project.
#' If a project is specified using the project version, the project name is ignored if it
#' is also included as an argument.
#'
#' @param project Project name
#' @param project_version_id Project version. If this is specified, the `project` argument is ignored.
#' @return data.frame of run attributes for the project specified
#' @seealso \code{\link{list_models}}, \code{\link{list_datasets}},
#'          \code{\link{fetch_quantiles}}, \code{\link{fetch_draws}}
#'
#' @importFrom magrittr %>%
#' @importFrom lubridate ymd_hms
#' @importFrom dplyr arrange
#' @importFrom dplyr desc
#' @export
list_runs <- function(project = NULL, project_version_id = NULL) {
  pv_id <- .process_project_inputs(project = project, project_version_id = project_version_id)
  ret <- geco_api(IRUNS, project_version_id = pv_id)
  if (length(ret$content) > 0) {
    d <- ret$content %>%
      purrr::map(purrr::map_if, ~ is.list(.x) & length(.x) > 1, ~ list(.x)) %>%
      purrr::map_dfr(tibble::as_tibble_row)
    # convert run_started_at into date-time field
    if ('run_started_on' %in% names(d)) {
      d <- d %>%
        dplyr::mutate(run_start_datetime = lubridate::ymd_hms(.data$run_started_on))
    }
    d <- d %>%
      dplyr::rename_at(.vars = dplyr::vars(-dplyr::starts_with('run_'),
                                           -.data$dataset_id, -.data$model_id),
                       .funs = ~ stringr::str_c('run_', .x))
  } else {
    d <- tibble::tibble(run_id = character(0))
    futile.logger::flog.info('No runs returned.')
  }
  d %>% dplyr::arrange(desc(.data$run_started_on))
}

.get_run <- function(project_version_id, run_id) {
  ret <- geco_api(IRUNS, project_version_id = project_version_id,
                  url_query_parameters = list(run_id = run_id))
  if (length(ret$content) == 1) {
    d <- ret$content %>%
      purrr::map(purrr::map_if, ~ is.list(.x) & length(.x) > 1, ~ list(.x)) %>%
      purrr::map_dfr(tibble::as_tibble_row)
    # convert run_started_at into date-time field
    if ('run_started_on' %in% names(d)) {
      d <- d %>%
        dplyr::mutate(run_start_datetime = lubridate::ymd_hms(.data$run_started_on))
    }
    d <- d %>%
      dplyr::rename_at(.vars = dplyr::vars(-dplyr::starts_with('run_'),
                                           -.data$dataset_id,
                                           -.data$model_id),
                       .funs = ~ stringr::str_c('run_', .x))
  } else {
    d <- tibble::tibble(run_id = character(0))
    futile.logger::flog.info('No runs returned.')
  }
  d
}

#' List the parameter names for a run
#'
#' List the parameter names from the Generable API for a specific run.
#'
#' A run is generated by a model and a dataset. This function retrieves the
#' names of all parameters for a specific run as a vector. This can be used in
#' \code{\link{fetch_quantiles}}.
#'
#' Authentication (see \code{\link{login}}) is required prior to using this function
#' and this pulls the list of parameter names from the Generable API.
#'
#' A project can be specified by using the project name or a specific project version.
#' If a project is specified using the name, data is fetched for the latest version of the project.
#' If a project is specified using the project version, the project name is ignored if it
#' is also included as an argument.
#'
#' @param run_id Run id; required
#' @param project Project name
#' @param project_version_id Project version. If this is specified, the `project` argument is ignored.
#' @return vector of parameter names for the specified run
#' @seealso \code{\link{list_models}}, \code{\link{list_datasets}},
#'          \code{\link{fetch_quantiles}}, \code{\link{fetch_draws}}
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr filter
#' @export
list_parameter_names <- function(run_id, project = NULL, project_version_id = NULL) {

  pv_id <- .process_project_inputs(project = project, project_version_id = project_version_id)
  run <- .get_run(project_version_id = pv_id, run_id = run_id)
  return(sort(unlist((run %>% dplyr::pull(.data$run_quantiles))[[1]]$parameter_names)))
}

#' List the predictive names for a run
#'
#' List the predictive names from the Generable API for a specific run.
#'
#' A run is generated by a model and a dataset. This function retrieves the
#' names of all predictive quantities for a specific run as a vector. This can be used in
#' \code{\link{fetch_quantiles}}.
#'
#' Authentication (see \code{\link{login}}) is required prior to using this function
#' and this pulls the list of predictive names names from the Generable API.
#'
#' A project can be specified by using the project name or a specific project version.
#' If a project is specified using the name, data is fetched for the latest version of the project.
#' If a project is specified using the project version, the project name is ignored if it
#' is also included as an argument.
#'
#' @param run_id Run id; required
#' @param project Project name
#' @param project_version_id Project version. If this is specified, the `project` argument is ignored.
#' @return vector of predictive names for the specified run
#' @seealso \code{\link{list_models}}, \code{\link{list_datasets}},
#'          \code{\link{fetch_quantiles}}, \code{\link{fetch_draws}}
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr filter
#' @export
list_predictive_names <- function(run_id, project = NULL, project_version_id = NULL) {
  pv_id <- .process_project_inputs(project = project, project_version_id = project_version_id)
  run <- .get_run(project_version_id = pv_id, run_id = run_id)
  return(sort(unlist((run %>% dplyr::pull(.data$run_quantiles))[[1]]$predictive_names)))
}


#' Find and filter runs on key features
#'
#' This function is a higher-level wrapper around \code{\link{list_runs}} to aid in run discovery
#'
#' A run is generated by a model and a dataset. This function retrieves the
#' key features for all runs meeting certain criteria within a project version.
#'
#' The returned `data.frame` combines information about the run, model, and datasets
#' for each run.
#'
#' Authentication (see \code{\link{login}}) is required prior to using this function
#' and this pulls the list of parameter names from the Generable API.
#'
#' @param project Project name
#' @param project_version_id Project version. If this is specified, the `project` argument is ignored.
#' @param model_type (character vector) filter to runs with this model type, as one of: joint, survival, biomarker. NULL to disable this filter.
#' @param model_version (character vector) filter to runs with this model version string. NULL to disable this filter.
#' @param min_draws (scalar int) filter to runs with >= this many draws combined across all chains. NULL to disable this filter.
#' @return a data frame with key metadata about the run.
#' @seealso \code{\link{list_runs}}, \code{\link{list_models}}, \code{\link{list_datasets}},
#'          \code{\link{fetch_quantiles}}, \code{\link{fetch_draws}}
#' @export
find_runs <- function(project = NULL, project_version_id = NULL,
                      model_type = NULL, model_version = NULL,
                      min_draws = 100) {
  # format inputs
  checkmate::assert_character(model_type, null.ok = TRUE, unique = TRUE)
  checkmate::assert_character(model_version, null.ok = TRUE, unique = TRUE)
  checkmate::assert_int(min_draws, null.ok = TRUE)
  if (!is.null(model_type))
    model_type <- match.arg(model_type, choices = c('joint', 'biomarker', 'survival'), several.ok = TRUE)
  pv_id <- .process_project_inputs(project = project, project_version_id = project_version_id)

  # get run info
  run_info <- list_runs(project_version_id = pv_id) %>%
    dplyr::left_join(list_datasets(project_version_id = pv_id),
              by = 'dataset_id') %>%
    dplyr::left_join(list_models(project_version_id = pv_id),
              by = 'model_id') %>%
    extract_subsample_info() %>%
    tidyr::unnest_wider(.data$run_args) %>%
    dplyr::mutate(run_started_on = lubridate::ymd_hms(.data$run_started_on))

  # process filters
  if (!is.null(model_type)) {
    run_info <- run_info %>%
      dplyr::filter(.data$model_type %in% !!model_type)
  }
  if (!is.null(model_version)) {
    run_info <- run_info %>%
      dplyr::filter(.data$model_version %in% !!model_version)
  }
  if (!is.null(min_draws)) {
    run_info <- run_info %>%
      dplyr::filter(.data$num_draws >= !!min_draws)
  }

  # show key fields
  return(
    run_info %>%
      dplyr::select(.data$run_id, .data$dataset_description, .data$sample_id,
                    .data$model_type, .data$model_version, .data$run_started_on))
}
